###c++(第四单元)

###c++风格字符串

尽管c++支持c风格的字符串，但是不应该在c++程序中使用这个类型，c风格字符串往往带来许多错误，是导致大量安全问题的根源。

c++语言通过（const）char* 类型的指针来操纵c风格字符串，一般来说，使用指针的算术操作来遍历c风格字符串，每次对指针进行测试并且递增+1，直到到达结束符null为止。  

	const char *cp="this is test";	
	while(*cp){
		//dosomething to this *cp
		++cp;	
	}
while循环的条件是对const char* 类型的指针cp进行解引用，并判断cp当前指向的字符是true还是false值。true表示这是除null之外的任意字符，则继续循环直到cp指向结束字符数组的null时，循环结束。执行完之后需要将指针位置移动到下一个位置。  

###c风格字符串的标准库函数

cstring 是string.h 头文件的c++版本，而string.h则是c语言提供的标准库。标准库将不会检查其字符串参数。  

	strlen(); //返回str的长度
	strcmp(s1,s2);//比较两个字符串是否相同
	strcat(s1,s2) //将s2拼接到s1之后，并且返回s1
	strcpy(s1,s2) //将s2复制给s1,并且返回s1
	strncat(s1,s2) ;
	strncpy(s1,s2) ;

传递给这些标准库函数的指针必须具有非零值，并且指向以null结束的字符串数组中的第一个元素，其中一些标准库函数会修改传递给它的字符串，这些函数将假定他们所修改的字符串具有足够大的空间来接受本函数新生成的字符，程序员必须确保目标字符串必须足够大。  

C++提供了普通关系操作符来实现标准库类型String的对象的比较，这些操作符也可用于指向c风格的指针的比较，但是效果却又很大的不同，实际上这时候指针存放的是地址值，而不是他们所指向的字符串：  

	if(cp1<cp2){
		//比较地址，not the value to compare
	}
	如果cp1以及cp2指向同一个数组中的元素（或该数组的溢出位置），上述表达式等效于比较在cp1和cp2中存放的地址；
	如果指向的是不同数组中的元素，则表达式则无具体的意义。

字符串的比较以及比较结果的解释都需要使用标准库函数strcmp进行解释：  

		//比较字符串函数，若相等返回值为0，若大于返回值为大于0，若小于的话返回值则小于0
		const char *cp1="A string example";
		const char *cp2="B string example";
		int i=strcmp(cp2,cp1);
		i=strcmp(cp1,cp1);

###需要记住字符串结束符NULL

在处理使用c风格的字符串的标准库函数时，牢记字符串必须以结束符NULL结束。所以需要尽量使用标准库类型string。

###创建动态数组

数组类型的变量有三个重要的限制：数组的长度固定不变，在编译的时候必须知道长度，数组只在定义他的语句块内存在，实际上的程序却需要动态的分配数组，	但是动态分配的数组不必再编译的时候知道其长度，通常在运行的时候才能确定数组的长度，与数组变量长度不同，动态分配的数组将一直存在，直到程序显示的释放它为止。  

c语言使用标准库函数 malloc 和 free 在自由存储区中分配存储空间，而C++使用 new 和 delete 表达式实现相同的功能。  

> 动态数组的定义，变量数组通过指定类型、数组名和维数来定义。动态分配数组时，只需指定类型和数组的长度，不必为数组对象命名，new 表达式返回的是指定数组对象的第一个元素的指针。后面加上()对数组元素做初始化。 

	int *p=new int[10] (); //array of 10 uninitialized ints
	对于动态分配的数组，其元素只能初始为元素类型的默认值，而不能像数组变量一样，用初始化列表
	为数组元素提供各不相同的初值。

###const对象的动态数组

如果我们在自由存储区中创建的数组存储了内置类型的const对象。则必须为这个数组提供初始化：因为元素对象都是const对象，无法赋值。实现这个要求的方法唯一方法是对数组做值初始化：  

	//错误的命名方式
	const int *pci_bad = new const int[100];
	//正确的初始化命名方式
	const int *pci_ok = new const int[100]();

c++允许定义类类型的const 数组。但是该类型必须提供默认构造函数：  

	// ok: array of 100 empty strings
	const string *pcs = new const string[100];	
	已经创建的常量元素将不允许修改-因为这样的数组实际上使用效果不大  

声明动态分配空数组  

> 之所以要动态分配数组。往往是由于编译的时候不知道数组的长度，可以编译如下代码：
> `size_t n=get_size() `  
>  `int *p=new int[n]`

用new创建动态数组时。new返回有效的非零指针。该指针与new返回的其他指针不同，因为不能进行解引用操作，因为没有指向任何元素。允许的操作包括：比较运算，因此该指针能在循环中使用；在该指针上加（减）0，或者减去本身，得0值。  

###动态空间的释放

动态分配的内存最后必须进行释放，否则最后内存将会耗尽，如果不再需要使用动态创建的数组，程序员必须显示的将其占用的存储空间返还给程序的自由存储空间，C++为指针提供了delete[] 表达式来释放所指向的数组空间：  

		delete [] pia; //该语句回收了pia所指向的数组，把相应的内存返还给了自由存储区，在
		关键字delete和指针之间的方括号是不可或缺的：它告诉编译器该指针指向了自由存储区中的
		数组而不是单个对象。

例如类似下面的代码：  

		const char *pc="this is a very long char";
		const size_t len=strlen(pc+1); // 指针所指向的字符串 -1 。默认加载NULL标志位 +1  

###动态数组的使用

在编译的时候倘若不知道数组的维度的时候，需要使用动态数组，例如在程序执行的过程中，常常使用char* 指针来指向多个c风格的字符串，于是必须根据每个字符串的长度实时的动态分配存储空间，这种技术要比采用大容量的数组要安全的多。 标准库函数strlen()返回的是字符串的长度，不包括NULL结束符的长度，因为结尾长度需要加1，以便于在动态分配的时候预留结束符的存储空间。

###混合使用标准库类型string和c风格字符串

>可以使用字符串字面值初始化string 类对象：  
>string str1("this the test world");

例如以下的代码：  

		char *str = st2; // compile-time type error	转换类型错误
		但是在要求c风格字符串的地方不能直接使用标准库string 类型对象
		char *str = st2.c_str(); // almost ok, but not quite 
### 多维数组

严格的来说，c++没有多维数组，通常所指的多维数组其实就是数组的数组。这一点有利于理解多维数组的定义。例如int a[2][3] 第一维度则为行数，第二维度则为列数。

###指针和多维数组

与普通数组一样，使用多维数组的时候，实际上将其自动转换为指向该数组的第一个元素的指针，定义指向多维数组的指针的时候，需要牢记指针所指向的多维数组其实就是数组的数组。

-----
###第五章 表达式

C++提供了丰富的操作符，并定义操作数为内置类型时，这些操作符的定义。C++还支持`操作符重载`，允许程序员自定义用于类类型时操作符的含义，标准库就是利用这种功能定义用于库类型的操作符。每个表达式都将会产生一个结果，如果表达式中没有操作符，则其结果就是操作数本身。
		

		