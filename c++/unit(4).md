###c++(第四单元)

###c++风格字符串

尽管c++支持c风格的字符串，但是不应该在c++程序中使用这个类型，c风格字符串往往带来许多错误，是导致大量安全问题的根源。

c++语言通过（const）char* 类型的指针来操纵c风格字符串，一般来说，使用指针的算术操作来遍历c风格字符串，每次对指针进行测试并且递增+1，直到到达结束符null为止。  

	const char *cp="this is test";	
	while(*cp){
		//dosomething to this *cp
		++cp;	
	}
while循环的条件是对const char* 类型的指针cp进行解引用，并判断cp当前指向的字符是true还是false值。true表示这是除null之外的任意字符，则继续循环直到cp指向结束字符数组的null时，循环结束。执行完之后需要将指针位置移动到下一个位置。  

###c风格字符串的标准库函数

cstring 是string.h 头文件的c++版本，而string.h则是c语言提供的标准库。标准库将不会检查其字符串参数。  

	strlen(); //返回str的长度
	strcmp(s1,s2);//比较两个字符串是否相同
	strcat(s1,s2) //将s2拼接到s1之后，并且返回s1
	strcpy(s1,s2) //将s2复制给s1,并且返回s1
	strncat(s1,s2) ;
	strncpy(s1,s2) ;

传递给这些标准库函数的指针必须具有非零值，并且指向以null结束的字符串数组中的第一个元素，其中一些标准库函数会修改传递给它的字符串，这些函数将假定他们所修改的字符串具有足够大的空间来接受本函数新生成的字符，程序员必须确保目标字符串必须足够大。  

C++提供了普通关系操作符来实现标准库类型String的对象的比较，这些操作符也可用于指向c风格的指针的比较，但是效果却又很大的不同，实际上这时候指针存放的是地址值，而不是他们所指向的字符串：  

	if(cp1<cp2){
		//比较地址，not the value to compare
	}
	如果cp1以及cp2指向同一个数组中的元素（或该数组的溢出位置），上述表达式等效于比较在cp1和cp2中存放的地址；
	如果指向的是不同数组中的元素，则表达式则无具体的意义。

字符串的比较以及比较结果的解释都需要使用标准库函数strcmp进行解释：  

		//比较字符串函数，若相等返回值为0，若大于返回值为大于0，若小于的话返回值则小于0
		const char *cp1="A string example";
		const char *cp2="B string example";
		int i=strcmp(cp2,cp1);
		i=strcmp(cp1,cp1);

###需要记住字符串结束符NULL

在处理使用c风格的字符串的标准库函数时，牢记字符串必须以结束符NULL结束。所以需要尽量使用标准库类型string。

###创建动态数组

数组类型的变量有三个重要的限制：数组的长度固定不变，在编译的时候必须知道长度，数组只在定义他的语句块内存在，实际上的程序却需要动态的分配数组，	但是动态分配的数组不必再编译的时候知道其长度，通常在运行的时候才能确定数组的长度，与数组变量长度不同，动态分配的数组将一直存在，直到程序显示的释放它为止。  

c语言使用标准库函数 malloc 和 free 在自由存储区中分配存储空间，而C++使用 new 和 delete 表达式实现相同的功能。  

> 动态数组的定义，变量数组通过指定类型、数组名和维数来定义。动态分配数组时，只需指定类型和数组的长度，不必为数组对象命名，new 表达式返回的是指定数组对象的第一个元素的指针。后面加上()对数组元素做初始化。 

	int *p=new int[10] (); //array of 10 uninitialized ints
	对于动态分配的数组，其元素只能初始为元素类型的默认值，而不能像数组变量一样，用初始化列表
	为数组元素提供各不相同的初值。

###const对象的动态数组

如果我们在自由存储区中创建的数组存储了内置类型的const对象。则必须为这个数组提供初始化：因为元素对象都是const对象，无法赋值。实现这个要求的方法唯一方法是对数组做值初始化：  

	//错误的命名方式
	const int *pci_bad = new const int[100];
	//正确的初始化命名方式
	const int *pci_ok = new const int[100]();

c++允许定义类类型的const 数组。但是该类型必须提供默认构造函数：  

	// ok: array of 100 empty strings
	const string *pcs = new const string[100];	
	已经创建的常量元素将不允许修改-因为这样的数组实际上使用效果不大  

声明动态分配空数组  

> 之所以要动态分配数组。往往是由于编译的时候不知道数组的长度，可以编译如下代码：
> `size_t n=get_size() `  
>  `int *p=new int[n]`

用new创建动态数组时。new返回有效的非零指针。该指针与new返回的其他指针不同，因为不能进行解引用操作，因为没有指向任何元素。允许的操作包括：比较运算，因此该指针能在循环中使用；在该指针上加（减）0，或者减去本身，得0值。  

###动态空间的释放

动态分配的内存最后必须进行释放，否则最后内存将会耗尽，如果不再需要使用动态创建的数组，程序员必须显示的将其占用的存储空间返还给程序的自由存储空间，C++为指针提供了delete[] 表达式来释放所指向的数组空间：  

		delete [] pia; //该语句回收了pia所指向的数组，把相应的内存返还给了自由存储区，在
		关键字delete和指针之间的方括号是不可或缺的：它告诉编译器该指针指向了自由存储区中的
		数组而不是单个对象。

例如类似下面的代码：  

		const char *pc="this is a very long char";
		const size_t len=strlen(pc+1); // 指针所指向的字符串 -1 。默认加载NULL标志位 +1  

###动态数组的使用

在编译的时候倘若不知道数组的维度的时候，需要使用动态数组，例如在程序执行的过程中，常常使用char* 指针来指向多个c风格的字符串，于是必须根据每个字符串的长度实时的动态分配存储空间，这种技术要比采用大容量的数组要安全的多。 标准库函数strlen()返回的是字符串的长度，不包括NULL结束符的长度，因为结尾长度需要加1，以便于在动态分配的时候预留结束符的存储空间。

###混合使用标准库类型string和c风格字符串

>可以使用字符串字面值初始化string 类对象：  
>string str1("this the test world");

例如以下的代码：  

		char *str = st2; // compile-time type error	转换类型错误
		但是在要求c风格字符串的地方不能直接使用标准库string 类型对象
		char *str = st2.c_str(); // almost ok, but not quite 
### 多维数组

严格的来说，c++没有多维数组，通常所指的多维数组其实就是数组的数组。这一点有利于理解多维数组的定义。例如int a[2][3] 第一维度则为行数，第二维度则为列数。

###指针和多维数组

与普通数组一样，使用多维数组的时候，实际上将其自动转换为指向该数组的第一个元素的指针，定义指向多维数组的指针的时候，需要牢记指针所指向的多维数组其实就是数组的数组。

-----
###第五章 表达式

C++提供了丰富的操作符，并定义操作数为内置类型时，这些操作符的定义。C++还支持`操作符重载`，允许程序员自定义用于类类型时操作符的含义，标准库就是利用这种功能定义用于库类型的操作符。每个表达式都将会产生一个结果，如果表达式中没有操作符，则其结果就是操作数本身。  

在单个表达式中组合使用解引用和自增操作  

例如下面的程序示例：  

		vector<int>::iterator it=ivec.begin();
		while(it!=ivec.end()){
			count << *it << endl;
			it++;	 
			//此处代码也可以写为：
			count << *it++ << endl;
			
			//同样显示的能遍历循环vector中对象的值。自增操作符的优先级高于解引用的优先级
			所以等效于 *(it++) 获取下一个元素的值
		}

>代码编写秉承着简洁即为美的原则		

### 箭头操作符

c++为包含点操作符和解引用操作符的表达式提供了一个同义词：箭头操作符`->`。点操作符用于获取类类型的成员：  

		item.same_isbn(item2); // 比较书籍的isbn编码

因为解引用的优先级小于点操作符的优先级。所以需要加上（）来优先进行解引用操作。但是编程时很容易忘记圆括号，而且这类代码又经常使用，所以在c++中为点操作符使用解引用操作定义了一个同义词`箭头操作符`假设有一个指向类类型对象的指针（或者迭代器）。下面的表达式是等效的：  

	(*p).foo();
	p->foo();

###条件操作符

条件操作符是c++中唯一一个三元操作符，允许将简单的if-else判断语句嵌入表达式中。条件操作符的语法格式跟java一样。

###sizeof 操作符

sizeof操作符的作用是返回一个对象或类型名的长度，返回值类型是size_t，长度的单位是字节，size_t 表达式的结果是编译时常量。  

使用sizeof的结果部分地依赖所涉及类型：  

* 对char类或者值为char类型的表达式做sizeof操作保证得1；
* 对引用类型做sizeof操作将返回存放此类型对象所需的内在空间大小
* 对指针做sizeof操作将返回存放指针所需的内在大小，注意，要获取该指针所指向的对象的大小，则必须对指针进行解引用操作。
* 对数组进行sizeof操作将等效于对其元素类型做sizeof操作结果乘以数组元素个数。  

### new 以及 delete 表达式   

耗尽内存将会抛出异常bad_alloc的异常.

###撤销动态创建的对象

动态创建的对象用完之后，程序员必须要显式的将该对象占用的内存返还给自由存储区，c++提供了delete表达式来释放指针所指向的地址空间。  

		delete pi; // 该命令释放了pi所指向的对象所占用的内存空间。如果指针指向的是不是用
		new分配的内存地址，则在该指针上使用delete是不合法的。  
编译的时候只能是指针，必须是动态创建的对象才能使用delete来进行销毁所占用的内存。通常来说，编译器不能检查一个指针指向什么类型的对象，因此尽管有些delete语句是错误的，但是在大部分编译器上仍然能编译通过。  

删除指针之后，指针将变为悬垂指针，悬垂指针指向曾近存放对象的内存，但是对象已经不存在了。悬垂指针往往导致程序错误，而且很难检测出来。一旦删除了指针所指向的对象，立即将指针置为0 ，这样就清楚的表明指针不在指向任何对象。


###显式转换类型

显式转换类型也称为强制类型转化（cast）,包括以下的强制转换类型操作符:static_cast、dynamic_cast、const_cast和reinterpret_cast. 虽然有时候需要强制转换类型，但是本质上是很危险的。  

dynamic_cast 支持运行时识别指针或者引用所指向的对象。  

const_cast 将参数的const性质转换掉  

static_cast 编译器隐式执行的任何类型转换都可以由static_cast 显式完成。  

###旧式的类型转换  

在使用命名的强制转换类型转换操作符之前，显式强制转换用圆括号将类型括起来实现：  

		char *pi=(char*) ip;

----

###第六章  语句

语句中声明方法类似于java中声明的方法，其中包含了`;` 来代表的空语句。无关的空语句并非总是无害的。  

声明语句：在c++中对象或者类的定义或声明也是语句。尽管定义语句这种说法也许更加准确，但是定义语句经常被称之为声明语句。  


###try块和异常处理 以及 异常定义

c++标准库定义了一组类，用于处理标准库中函数遇到的问题。程序员可以在自己编写的程序中使用这些标准异常类。标准异常类定义在四个头文件中：  

1、exception 头文件定义了最常见的异常类，它的类名是exception 这个类只通知异常的产生，但不会提供更多的信息。  

2、stdexcept 定义了几种常见的异常类，如下所示：  

| ------------- |:-------------:|
| exception      | 最常见的问题   |
| runtime_error  | 运行时检查错误 |

标准库异常类  

标准库异常类只提供了很少操作、包括创建、复制异常类型对象以及异常对象的赋值。exception、bad_cast异常类型只定义了默认构造函数，无法再创建这些类型的对象时为他们提供初值。其他的类型则只定义了一个使用string初始化的构造函数。string 初始化式用于为所发生的错误提供更新的信息。  

异常类型只定义了一个名为what的操作，这个函数不需要任何参数，并且返回了const *char 类型值。它返回的指针指向一个C风格的字符串。使用c风格字符串的目的是为所抛出的异常提供更详细的文字描述。

###预处理器进行调试
		#ifndef NDEBUG
		cerr << "starting main" << endl;  
		#endif

预处理器还定义了其余四种在调试时非常有用的常量：  

_FILE_文件名  

_LINE_当前行号  

_TIME_文件被编译时间  

_DATE_文件被编译日期  

另一个常见的调试技术是使用NDEBUG预处理变量以及assert预处理宏。`预处理宏`是在assert头文件中调用的，所有使用assert的文件都必须包含这个头文件。如果该表达式结果为false,则输出信息，并且终止程序的运行。  

-----

###第七章 函数的定义

函数体是一个语句块，定义了函数的具体操作，形参与实参差别在于形参是在函数的形参表中定义的，并且是由调用函数时传递函数的实参初始化。  

函数不能返回另一个函数或者内置数组类型，但是可以返回指向函数的指针，或者指向数组元素的指针的指针。  

		int *foo_bar(){/* ---------- */}; //这个函数返回一个int型的指针
		该指针可以指向数组中的一个元素。  
应该将不需要修改的引用形参定义为const引用，普通的非const引用形参在使用时候不太灵活，这样产生的形参不能使用const 对象初始化又不能用字面值或产生右值得表达式实参初始化。  


### vector和其他容器类型的形参

通常来说，函数不应该有vector或者其他标准容器类型的形参，调用含有普通的非引用vector形参的函数将会复制一个vector的每一个元素。  

###c++中的省略符形参

C++中的省略符形参是为了编译使用varargs的c语言程序，对于c++程序只能将简单的数据类型传递给含有省略符形参函数。实际上，当需要传递给省略符形参时。大多数类型对象都不能正确的复制。省略符形参有如下的类型：  

		void foo(parm_list,...);
		void foo(...);  

在返回值为void的函数中可以不存在return语句。隐式的return语句发生在代码执行完成之后。  


主函数main()的返回值。关于主函数返回的另一个特别之处在于如何处理他的返回值。可以将main（）h函数的返回值视为状态指示器。返回0表示程序运行成功，其他部分的值则表示返回不成功。cstdlib 定义了两个预处理变量，分别表示程序运行成功以及失败。  

		#include <cstdlib>
		int main(){
			if(some_case){
				return EXIT_FAILURE;
			}else{
				return EXIT_SUCCESS;
			}
		}

###函数声明

函数必须在被调用之前先声明，于变量的定义类似。函数的声明也可以和函数的定义分离，一个函数只能定义一次，但是可以声明多次。  

函数的声明由函数的返回类型、函数名和形参列表组成，形参列表必须包括形参类型，但是不必对形参命名，这三个函数被称之为函数原型，函数原型描述了函数的接口。  

函数原型为定义函数的程序员以及使用函数的程序员之间提供了接口，在使用函数的时候，程序员只对函数原型进行编程即可。  

函数声明中的形参名都将会被省略，如果在声明中给出了形参的名字。他应该做辅助文档。

###在头文件中声明

在头文件中可以对变量进行声明，而在源文件中对定义，同理函数也可以在头文件中声明，并且在源文件中定义。  

如果函数接口发生了变化，则只要修改其中唯一的声明即可。定义函数的源文件应该包含声明该函数的头文件。

###默认实参

默认实参是一种虽然并不普遍、但是在多数情况下任然适用的实参值，调用函数时，可以省略有默认实参的实参，编译器将会提供我们省略的实参提供默认值。  

制定默认实参的约束，既可以在函数声明也可以在函数定义中指定默认实参，但是，在一个文件中只能为一个形参制定默认实参一次。


------

###7.5局部对象

c++中每个名字都有一个作用域，每个对象都有生命期，要弄清楚函数是怎么运行的，必须明白这两个概念。在函数中定义的形参和变量的名字只位于函数的作用域中：这些名字只在函数体中可见。通常，变量名从声明或定义的地方开始到包围它的作用域结束处都是可用的。

###自动对象

只有当定义它的函数被调用时候才存在的对象被称之为自动对象，自动对象在每次调用函数时候创建和撤销。如果在定义的时候提供了初始化，那么每次创建对象的时候，对象都会被赋予指定的值，对于未初始化的内置局部对象，其初值不确定，当函数调用结束的时候，自动对象就会被撤销。  

形参也是自动对象，形参所占用的存储空间在调用函数的时候创建，而在函数结束的时候销毁。  

###静态局部对象

如果一个变量位于函数的作用域内，但是声明周期跨越了这个函数的多次调用，这种变量往往是有用的，则应该将这样的变量定义为static（静态的）

###类的成员函数

成员函数也包括下面四个部分：  
1、函数的返回类型  
2、函数名  
3、用逗号隔开的形参表（也可能是空的）  
4、包含在一对花括号里面的函数体  

###定义成员函数的函数体 

类的所有成员都必须定义在类定义的花括号里面声明，此后就不能在为类增加任何成员。类的成员函数必须如声明的一般定义。类的成员函数既可以在类的定义内可以在类的定义外定义。

###成员函数含有额外的、隐含的形参

调用成员函数的时候，实际上是使用对象来调用的,而没有前缀的都是使用了相同的实参绑定过程，使之为total对象绑定起来，每个成员函数都有一个额外的、隐含的参数与调用该函数的类的对象绑定在一起。 

###this指针的引入

每个成员函数都有一个额外的隐含的形参this。在调用成员函数的时，形参this初始化为调用函数对象的地址，为了理解成员函数的调用。可考虑下面的写法：  

		bool same_isbn(const Sales_item &rhs) const{ 
			return isbn == rhs.isbn; 
		}
		编译器重写之后的代码:
		Sales_item::same_isbn(&total, trans);

###const成员函数的引入

成员函数声明的形参表后面的const所起的作用就是const改变了隐含的this形参的类型，在调用total.same_isbn()函数时候，隐含的this形参将指向一个total对象const类型指针参数。


###编写C++构造函数

定义类的时候没有初始化他的数据成员，而是通过构造函数来初始化其数据成员。构造函数时特殊的成员函数，一个类可以有多个构造函数，每个构造函数必须有与其他构造函数不同数目或类型的参数。  

构造函数形参指定了创建类类型对象使用的初始化式，通常这些初始化式会用于初始化创建的时候直接进行初始化。  

###重载函数

出现在作用域里面的两个函数，如果是具有相同的名字而形参不相同，则称之为重载函数。函数重载简化了程序的实现，使程序便于理解，函数重载使得可以定义一系列的函数，如以下的代码所示：  

		lookup(const Account&):
		lookup(const Phone&);
		lookup(const Name&);
		任何函数都仅有一个main()函数，main()函数不能进行重载。

如果两个函数的返回类型以及形参完全匹配，则将第二个函数声明视为第一个的重复声明，如果形参相同但是返回类型不同，则第二个声明是错误的。  

一些定义函数的代码书写方式:  

		TestCppName test(const Account &account);
		TestCppName test(const Account&); //以上两种写法其实是一样的，第二种写法省略了参数
		typedef Phone Telno;
		Record lookup(const Phone&);
		Record lookup(const Telno&); 
		Record lookup(const Phone&, const Name&);
		第一种命名方式，第一个声明给它的形参命名，形参名只是帮助文档。

###重载作用域

在函数中局部声明的名字将屏蔽在全局作用域内声明的同名名字。这个关于变量名字性质对于函数名同样成立。




			