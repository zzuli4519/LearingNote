###函数的定义

全局函数的声明是在类定义之前是不可见的，需要考虑在成员函数定义出现之前的全局作用域的声明。  
例如代码如下所示:  

			class MyTest{
				public:
				 	void set_height(index);
				private:
					index height;			
			};
			MyTest::index verify(MyTest::index);
			//实现全局定义的函数，借此子类实现
			void MyTest::set_height(index var){
				height=verify(var);
			}
###构造函数

构造函数时成员特殊的函数，只要创建类类型的新对象，都要执行新的构造函数，构造函数的工作是保证每个对象的数据成员具有合适的初始值。

> 构造函数可以没有形参或者是定义多个形参  
> 构造函数可以被重载，并且传入的实参决定了构建对象的时候使用哪一个构造函数。  
>构造函数自动运行，只要创建一个函数的对象，编译器就运行一个构造函数。  

###用于const对象的构造函数

构造函数不能被声明为const类型:  

		class Test{
			public：
				Test() const; // error 错误的构造器函数格式，不管对象是否为const类型，
				//都需要创建构造一个类类型的对象
				Test(): name("hello world"){}
			private:
				std::string name;
		};
###构造函数的初始化式

与任何的其他函数一样，构造函数必须有名字，形参以及函数体组成，与其他函数不同的是，构造函数也是一个可以包含一个构造函数初始化列表：  

	Test::Test: name("hello world"){}  //外部调用Test类类型形式
构造函数初始化列表以一个：开始，接着是一逗号进行分割的数据成员列表，每个数据成员后面需要加上一个放在圆括号中的初始化式，这个构造函数将是初始化为形参的值。与任意的函数一样，构造函数可以定义在类的内部或者外部，构造函数初始化只在构造函数中进行定义，而不能在函数声明中进行定义。需要注意这一点。
>在构造函数体内对数据成员进行赋值是合法的。  

例如一下代码所示:  

		Test(std::string name_test){
			name=name_test;
		}
可以认为函数存在构造的两个阶段，函数分为两个阶段组成：1、初始化阶段 2、计算阶段。计算阶段由构造函数体中的所有语句组成。  

对于有些成员必须在构造函数初始化列表中进行初始化。对于这样的成员，在构造体函数体中对他们进行赋值不起作用，没有默认的构造函数的类类型的成员，以及const或引用类型的成员，不管是哪种类型，都必须在构造函数初始化列表中进行初始化操作。  

因为内置类型的成员不进行隐式初始化，所以对这些成员是进行初始化还是赋值都是无关紧要的，但是对于类类型的数据成员进行赋值或使用初始化在结果和性能上都是等价的。  

可以初始化const对象或者引用类型的对象，但是不能对他们进行赋值，在开始构造函数的函数体之前，要完成初始化。初始化const或者引用类型数据成员的唯一机会是在构造函数的初始化列表中。  

> 必须对任何const或引用类型成员以及没有默认构造函数的类类型的任何成员使用初始化式。  
> 当类成员需要使用初始化列表的时候，通常常规的使用构造函数初始化列表，就可以避免发生编译时的错误。  
> 按照数据成员声明一致的次序编写构造函数初始化列表，此外，尽可能的避免使用成员来初始化其他的成员。  

一般情况下，可以通过重复使用构造函数的形参而不是使用对象的数据成员，可以避免由初始化的执行次序而引起的任何问题，例如如下代码：  

		Test(std::string value_test):name(value_test){}  
		//初始化式可以是任意的表达式  
		一个初始化式可以是任意的复杂的表达式。

###类类型的数据成员初始化式

初始化类类型成员时候，要制定实参并传递给成员类型的一个构造函数，可以使用该类型的任意构造函数。例如可以使用Test的构造函数类初始化类类型的对象。`Test(): test("hello world"){}`  

###默认实参与构造函数  

默认构造函数接受一个string的构造函数的定义：  
		
		Test(const std::string name_value):name(name_value){} 
类通常应该定义一个默认的构造函数  

在某些情况下，默认构造函数是由编译器隐式应用的，如果没有默认构造函数，则该类就不能用在这些环境中。  

###隐式类类型转换  

c语言定义了内置类型之间的几个自动转换，也可以定义如何将其他类型的对象隐式的转换为我们的类类型，或者将我们的类类型对象转化为其他的类型，为了定义到类类型的隐式转换，需要定义合适的构造函数

抑制由构造函数定义的隐式转换，可以将函数声明为explicit`明确的` ，来防止在需要在隐式转换的上下文中使用构造函数，隐式转化函数在使用构造函数对象的时候一般能够得到使用。explicit关键字能够避免使用隐式的转换数据类型。只能使用明确的数据转换类型来定义数据。  

###抽象函数的使用 struct 

对于没有定义构造函数并且全部数据成员均为public的类，可以采用于初始数组元素相同的方式来初始化其成员:  
	
		struct Data{
			int ival;
			char *ptr;
		}

		Data val1=Data{0,0}; 
		Data val2 = { 1024, "Anna Livia Plurabelle" };
		// 以上两种定义方式都是合法的
显式初始化函数对象是基于c编译的而来进行定义的，支持与c语言的兼容，显式初始化类类型对象的成员有三个重大的缺点：  
1. 所有的全体数据成员只能是public类型  
2. 将初始化每个对象的任务全部放在程序员身上，容易出错   
3. 如果增加或者删除一个成员，必须找到所有的初始化并正确的更新  
4. 定义和使用构造函数几乎总是较好的，当我们为自己定义的类型提供了一个默认的构造函数类型时，允许编译器自动运行决定哪一个构造函数

###友元机制

在某些情况下，允许特定的非成员函数访问一个类的私有成员，如输入输出操作符，经常需要访问类的私有数据成员，这些操作符不能成为类的成员，他们仍然是类的接口组成部分。  

友元关键字通过friend关键字来进行申明，只能定义在类的内部，友元可以出现在类中的任何地方。友元不是授予友元关系的那个类的成员，所以他们不受声明出现部分的访问控制影响。通常将友元定义在类开始或者结束的地方将是一个好做法。  

如以下的代码所示：  

		class Test{
			friend class TestTwo;
			std::string name;
			std::string age;
		}

		class TestTwo{
			TestTwo & relocate(Test::name name_val,Test::age age_val,Test& test_val){
				test_val.name+=name_val;
				test_val.age+=age_val;
				return *this;
			}
		}

友元声明和友元定义之间的相互依赖，一般来讲，必须先定义包含成员函数的类，才能将成员函数设置为友元，另一方面，不必预先声明类和非成员函数来将他们设置为友元。  

###重载函数与友元的关系

类必须将重载函数集中每一个希望设置为友元的函数都设置为友元。  

	extern std::string get_name();

###static类成员

对于特定的类类型全体对象而言，访问一个全局对象是有必要的，也许在程序的任意点需要统计已经创建的特定类类型对象的数量；或者，全局对象可能是指向类的错误处理例程的一个指针。类可以定义为类静态成员。而不是定义一个可以普遍访问的全局对象。  

通常的时候，非static数据成员存在于类类型的每个对象中。不像普通的数据或者成员，static数据成员独立于该类的任意对象而存在；每个static数据成员是与类关联的对象，并不与类对象关联。   

使用static变量而不是全局对象有三个优点。  
1. static 成员名字是在类的作用域中，因此可以避免于其他类的成员或者全局对象名字发生冲突  
2. 可以实施封装，static可以是私有成员，而全局对象不可以  
3. static是与特定类关联，可以清晰明白程序员的用意  

static成员是类的组成部分但是不是任何对象的组成部分，因此static成员函数没有this指针，通过使用非static成员显示或者隐式的调用this是一个编译的错误，static成员不能被声明为const对象。static对象成员也不能被声明为虚函数。  

###static数据成员  

static数据成员可以申明为任意的类型，可以是常量、引用、数组、类类型、等等数据类型。  
static数据成员必须在类定义体的外部定义，static成员不是通过类构造函数进行初始化，而是因该在定义时候进行初始化。 保证类对象正好定义一次的最好办法就是讲定义static数据成员放到非内联成员函数定义的文件中。
