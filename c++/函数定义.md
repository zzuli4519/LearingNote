###函数的定义

全局函数的声明是在类定义之前是不可见的，需要考虑在成员函数定义出现之前的全局作用域的声明。  
例如代码如下所示:  

			class MyTest{
				public:
				 	void set_height(index);
				private:
					index height;			
			};
			MyTest::index verify(MyTest::index);
			//实现全局定义的函数，借此子类实现
			void MyTest::set_height(index var){
				height=verify(var);
			}
###构造函数

构造函数时成员特殊的函数，只要创建类类型的新对象，都要执行新的构造函数，构造函数的工作是保证每个对象的数据成员具有合适的初始值。

> 构造函数可以没有形参或者是定义多个形参  
> 构造函数可以被重载，并且传入的实参决定了构建对象的时候使用哪一个构造函数。  
>构造函数自动运行，只要创建一个函数的对象，编译器就运行一个构造函数。  

###用于const对象的构造函数

构造函数不能被声明为const类型:  

		class Test{
			public：
				Test() const; // error 错误的构造器函数格式，不管对象是否为const类型，
				//都需要创建构造一个类类型的对象
				Test(): name("hello world"){}
			private:
				std::string name;
		};
###构造函数的初始化式

与任何的其他函数一样，构造函数必须有名字，形参以及函数体组成，与其他函数不同的是，构造函数也是一个可以包含一个构造函数初始化列表：  

	Test::Test: name("hello world"){}  //外部调用Test类类型形式
构造函数初始化列表以一个：开始，接着是一逗号进行分割的数据成员列表，每个数据成员后面需要加上一个放在圆括号中的初始化式，这个构造函数将是初始化为形参的值。与任意的函数一样，构造函数可以定义在类的内部或者外部，构造函数初始化只在构造函数中进行定义，而不能在函数声明中进行定义。需要注意这一点。
>在构造函数体内对数据成员进行赋值是合法的。  

例如一下代码所示:  

		Test(std::string name_test){
			name=name_test;
		}
可以认为函数存在构造的两个阶段，函数分为两个阶段组成：1、初始化阶段 2、计算阶段。计算阶段由构造函数体中的所有语句组成。  

对于有些成员必须在构造函数初始化列表中进行初始化。对于这样的成员，在构造体函数体中对他们进行赋值不起作用，没有默认的构造函数的类类型的成员，以及const或引用类型的成员，不管是哪种类型，都必须在构造函数初始化列表中进行初始化操作。  

因为内置类型的成员不进行隐式初始化，所以对这些成员是进行初始化还是赋值都是无关紧要的，但是对于类类型的数据成员进行赋值或使用初始化在结果和性能上都是等价的。  

可以初始化const对象或者引用类型的对象，但是不能对他们进行赋值，在开始构造函数的函数体之前，要完成初始化。初始化const或者引用类型数据成员的唯一机会是在构造函数的初始化列表中。  

> 必须对任何const或引用类型成员以及没有默认构造函数的类类型的任何成员使用初始化式。  
> 当类成员需要使用初始化列表的时候，通常常规的使用构造函数初始化列表，就可以避免发生编译时的错误。  
> 按照数据成员声明一致的次序编写构造函数初始化列表，此外，尽可能的避免使用成员来初始化其他的成员。  

一般情况下，可以通过重复使用构造函数的形参而不是使用对象的数据成员，可以避免由初始化的执行次序而引起的任何问题，例如如下代码：  

		Test(std::string value_test):name(value_test){}  
		//初始化式可以是任意的表达式  
		一个初始化式可以是任意的复杂的表达式。

###类类型的数据成员初始化式

初始化类类型成员时候，要制定实参并传递给成员类型的一个构造函数，可以使用该类型的任意构造函数。例如可以使用Test的构造函数类初始化类类型的对象。`Test(): test("hello world"){}`  

###默认实参与构造函数  

默认构造函数接受一个string的构造函数的定义：  
		
		Test(const std::string name_value):name(name_value){} 
类通常应该定义一个默认的构造函数  

在某些情况下，默认构造函数是由编译器隐式应用的，如果没有默认构造函数，则该类就不能用在这些环境中。