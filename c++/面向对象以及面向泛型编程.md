###使用计数式复制控制  

复制控制成员适当地操纵使用计数和指针，复制对象包括复制两个指针和使用计数加1，析构函数将使用计数减1。如果计数减至0的时候就撤销指针，因为赋值操作符要完成同样的工作，所以在私有的析构函数中要实现析构函数的行为。  

句柄类通常需要在不知道对象确切类型分配对象类型，为了解决这个问题，所以通常的方式是定义虚函数进行复制，我们称之为该函数为clone。  

为了句柄类，我们需要从基类开始，在继承层次的每一个类中都增加clone，基类必须将该函数定义为虚函数，如以下的代码所示：  

```java
	class Base{
		public:
			virtual Base* clone() const {
				return new Base(*this);	
			}
	}
每个类都需要重新定义该虚函数，因为函数的存在是为了生成类对象的副本，所以定义返回类型为类本身
类似于java中实现的clone函数。
	
	*的作用为解引用
	class Subclass : public Base{
		public :
			Subclass* clone() const {
				return new Subclass(*this);
			}
	}
```

###定义句柄的构造函数

一旦有了clone函数，就可以这样编写句柄类，如以下代码所示：  

```java
	Sales_item::Sales_item(const Base &item):p(item.clone()),
	use(new std::size_t(1)){}
	像默认的构造函数一样，构造函数分配并且初始化使用计数，调用形参的clone产生那个对象的虚副本。
	如果实参是Base对象，则运行实参的clone函数。如果是派生类的话则运行的是派生类clone函数。
```

###使用带关联容器的比较器

如果使用比较函数，必须作为容器的部分而存储，任何在容器中增加或者查找元素的操作都要使用比较函数。原则上，每个这个的操作都接受一个可选的附加实参，表示比较函数，但是如果两个操作使用不同的比较函数，可能顺序不一样，也就不能预测实际发生什么。  

类似的对于添加到容器中需要实现在java中的compare函数。