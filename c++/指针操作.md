###复制函数，析构函数，赋值操作符----复制控制

对于类类型对象，只有指定单个实参或显式创建一个临时对象用于复制时，才可以复制初始化。复制构造函数就是接受单个类类型引用形参（通常需要使用const来进行修饰）的构造函数：  

		class Test{
			Test(std::string);
			Test(const Test&);
		} 
		//虽然也可以接受一个非const引用的复制构造函数，但是形参通常应该是一个const引用。 
		//不应该将隐式转换与复制构造函数混淆
定义构造函数一般比较简单，使用构造函数初始化列表可以创建新的类对象成员，可以在函数体中做其他任何必要的工作。  

####禁止复制

有些类要完全禁止复制，但是如果不定义复制函数的话，编译器将自动合成一个复制函数，为了便面复制函数，需要将复制函数显示的声明为private。如果复制函数是私有的，将不允许用户代码复制该类类型的对象，然而友元和成员是可以进行复制的，如果避免友元和成员的复制也禁止的话，就可以声明一个private复制构造函数，但是不比对其进行任何的定义。  

> 大多数的类应该定义复制构造函数和默认构造函数，不允许复制的类不能作为容器的元素。（注意点）


> 只有当类的定义体完成之后才能定义，因此类不能拥有自身类型的数据成员，然而只要类名一出现的话就是可以认为该类已经声明，也即因此类的数据成员可以是指向自身类型的引用或者指针。  

	class Test{
		Test* mem1;
		Test& mem2;
		//以上两种是合法的
		Test mTest; // 这种声明方式是错误的
	}

####重载操作符

重载操作符是一些函数，其名字为operator后面跟上操作符的符号。因此可以定义名为operator=函数。我们可以对赋值进行定义，像任何其他函数一样，操作符有一个返回值和一个形参表。形参表表示必须具有与该操作符数目相同的形参(如果操作符是一个类成员，则应该包括隐式this)大多数的操作符都是可以定义为成员函数或非成员函数。当操作符为成员函数的时候。它的第一个操作数隐式绑定到this指针。

####何时调用析构函数

撤销对象，清除对象所占用的引用的时候将会自动调用析构函数。  

如代码所示：  
		
		Test *p=new Test;
		{
			delete p; //删除占用对象引用			
		}

一个变量在超出作用域的时候应该自动撤销，因此当遇到右花括号的时候，将运行析构函数来执行清理程序。但是对于动态分配的指针之类的对象，只有在指针被删除时才会被撤销，如果没有删除指向动态对象的指针，将不会运行该对象的析构函数，对象就会一直存在，从而导致内存泄露的发生，而且对象内部使用的任何资源也不会得到释放。  

撤销一个容器，也将会运行容器中的类型元素的析构函数：  
		{
			Test *p=new Test[10];
			vector<Test> vec(p, p + 10);
			delete [] p;
		}

容器中的元素总是按照逆序的顺序执行销毁，直到撤销到下标为0的元素。析构函数通常用于释放在构造函数或在对象生命期内获取的资源进行清理工作。

>  需要注意的一点：如果一个类需要析构函数，则也需要复制函数以及赋值操作符，这被称之为`三法则`指的是如果需要析构函数则需要所有这三个复制控制成员。  
>  析构函数可以执行任意操作，一般是在对象使用完毕之后执行的。

####合成析构函数

编译器总是会为我们创建一个析构函数。合成析构函数按对象创建时逆序撤销每个非static成员。因此，他按照成员在类中声明次序的逆序撤销成员，对于每个类类型的每个成员，合成析构函数调用成员的析构函数来撤销对象。

####管理指针的成员

使用标准库能够大大减少现代c++程序对指针的需要，但是在类的实现中仍然需要有很多指针的使用，包含指针的类要特别注意复制控制，原因在于复制指针时只复制指针中的地址，而不会复制指针指向的对象。  

当两个指针指向了同一个对象的时候，可能使用任意一个指针改变基础对象，类似的，很可能一个指针删除了一个对象，另一指针的用户还认为基础对象还在这样的错误情况，所以需要注意。  

c++采取了以下三种方法来管理指针：  

1. 指针成员采取常规指针型行为。这样的类具有指针的所有缺陷但无需特殊的复制控制。  
2. 类可以实现所谓的“智能指针”行为。指针所指向的对象是共享的，但类能够防止悬垂指针。  
3. 类采取值型行为。指针所指向的对象是唯一的，由每个类对象独立管理。  
4. const成员函数可以修改其所指向的字符。也就是说一个函数尽管是const类型，但是任然可以修改指针所指向的对象  

> 类对象的常量性决定了调用哪一个函数  

类直接复制指针的情况下，可能存在潜在的问题，可能出现悬垂指针：资源已经被回收或者指针不在指向有效的对象的时候可能出现悬垂指针，但是没有办法得知对象是否已经不存在了。  

####定义智能指针  

智能指针负责删除共享对象。 使用智能指针需要设计一个管理指针的类来实现计数功能，其方法之一是使用一个单独的具体类用以封闭使用计数和相关指针。  

采用了复制构造函数的时候，相当于创建了一个新的指针对象，因为每个对象保存了自己的副本，所以析构函数可以无条件的删除指针。  

赋值操作符不需要分配新的对象，只是必须给其指针所指向的对象赋新的值，而不是给指针本身赋值。改变的是指针所指向的值，而不是指针。  

分配内存或其他资源几乎总是需要定义复制控制成员来管理所分配的资源，如果一个类需要析构函数，则它几乎也总是需要复制构造函数和赋值操作符。

###重载操作符和转换

重载操作符必须具有一个类类型的操作数。操作数不能是常规的数据类型。内置操作符的定义不能改变，也就因此不能重新定义。  

也不能为内置数据类型重新定义加号操作符。例如不能接受两个数组操作数operator+.  

> 重载操作符必须至少需要一个类类型或者是枚举类型的操作数，这条规则强制重载操作符不能重新定义用于内置类型对象的操作符的含义。  

####优先级和结合性是固定的

重载操作符并不能保证操作数的求值顺序，尤其是不会保证内置逻辑AND、逻辑OR和逗号操作符的操作数求值。在 && 和 || 的重载版本中，两个操作数都要进行求值，一次重载　&& 和 || 不是一个好的选择。  

调用成员操作符函数跟普通函数一样，指定函数并传递适当类型的适当数目的形参。也可以这么理解：  

> 指定运行函数的对象，然后使用.或者->操作符获取希望调用的函数，同时传递所需数目和类型的实参。对于二次元操作符函数的情况，必须传递一个操作数。  

并且大多数的操作符对类来说并没有多大的意义。  

####输入输出操作符的重载

更重要但通常重视不够的是，输入和输出操作符有如下区别：输入操作符必须处理错误和文件结束的可能性。  

####调用操作符以及函数对象

可以为了类类型对象重载函数调用操作符。一般表示为操作的类的重载调用操作符。例如可以存在如下的代码结构：  

		struct class Test{
			int opertor (int val){
			}
		}
		//执行以上代码则可以正确迅速调用代码结构作为函数使用
		
> 函数作为标准库算法的实现，以及函数对象可以比函数更加的灵活和便于操作  
> 每个标准库的函数表示一个给定的操作符。每个类都定义了应用命名操作的调用操作符，不同的函数对象定义了执行不同操作的调用操作符，等等。  

####标准库函数基本摘抄所示

|算术函数类型对象| - |
| ----- | ------ |
|plus<Type> |加法操作 | 
|minus<Type> |减法操作 | 
|multplies<Type> |乘法操作 | 
|divides<Type> |除法操作 | 

等等基本的操作都是可以先进行命名，然后直接调用操作符就可以了，如以下的代码所示：  

		plus<int> add_int;
		int sun=add_int(10,20);
		//得到的结果为两个数相加的和。其余的方法以此类推，可以直接先定义操作符，直接对两个数进行运
		算操作
> 函数对象经常会覆盖算法使用的默认操作符，如sort默认使用operator<按升序对容器进行排列>
 



