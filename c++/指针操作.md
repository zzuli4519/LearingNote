###复制函数，析构函数，赋值操作符----复制控制

对于类类型对象，只有指定单个实参或显式创建一个临时对象用于复制时，才可以复制初始化。复制构造函数就是接受单个类类型引用形参（通常需要使用const来进行修饰）的构造函数：  

		class Test{
			Test(std::string);
			Test(const Test&);
		} 
		//虽然也可以接受一个非const引用的复制构造函数，但是形参通常应该是一个const引用。 
		//不应该将隐式转换与复制构造函数混淆
定义构造函数一般比较简单，使用构造函数初始化列表可以创建新的类对象成员，可以在函数体中做其他任何必要的工作。  

####禁止复制

有些类要完全禁止复制，但是如果不定义复制函数的话，编译器将自动合成一个复制函数，为了便面复制函数，需要将复制函数显示的声明为private。如果复制函数是私有的，将不允许用户代码复制该类类型的对象，然而友元和成员是可以进行复制的，如果避免友元和成员的复制也禁止的话，就可以声明一个private复制构造函数，但是不比对其进行任何的定义。  

> 大多数的类应该定义复制构造函数和默认构造函数，不允许复制的类不能作为容器的元素。（注意点）


> 只有当类的定义体完成之后才能定义，因此类不能拥有自身类型的数据成员，然而只要类名一出现的话就是可以认为该类已经声明，也即因此类的数据成员可以是指向自身类型的引用或者指针。  

	class Test{
		Test* mem1;
		Test& mem2;
		//以上两种是合法的
		Test mTest; // 这种声明方式是错误的
	}

####重载操作符

重载操作符是一些函数，其名字为operator后面跟上操作符的符号。因此可以定义名为operator=函数。我们可以对赋值进行定义，像任何其他函数一样，操作符有一个返回值和一个形参表。形参表表示必须具有与该操作符数目相同的形参(如果操作符是一个类成员，则应该包括隐式this)大多数的操作符都是可以定义为成员函数或非成员函数。当操作符为成员函数的时候。它的第一个操作数隐式绑定到this指针。

####何时调用析构函数

撤销对象，清除对象所占用的引用的时候将会自动调用析构函数。  

如代码所示：  
		
		Test *p=new Test;
		{
			delete p; //删除占用对象引用			
		}

一个变量在超出作用域的时候应该自动撤销，因此当遇到右花括号的时候，将运行析构函数来执行清理程序。但是对于动态分配的指针之类的对象，只有在指针被删除时才会被撤销，如果没有删除指向动态对象的指针，将不会运行该对象的析构函数，对象就会一直存在，从而导致内存泄露的发生，而且对象内部使用的任何资源也不会得到释放。  

撤销一个容器，也将会运行容器中的类型元素的析构函数：  
		{
			Test *p=new Test[10];
			vector<Test> vec(p, p + 10);
			delete [] p;
		}

容器中的元素总是按照逆序的顺序执行销毁，直到撤销到下标为0的元素。析构函数通常用于释放在构造函数或在对象生命期内获取的资源进行清理工作。

>  需要注意的一点：如果一个类需要析构函数，则也需要复制函数以及赋值操作符，这被称之为`三法则`指的是如果需要析构函数则需要所有这三个复制控制成员。  
>  析构函数可以执行任意操作，一般是在对象使用完毕之后执行的。

####合成析构函数

编译器总是会为我们创建一个析构函数。合成析构函数按对象创建时逆序撤销每个非static成员。因此，他按照成员在类中声明次序的逆序撤销成员，对于每个类类型的每个成员，合成析构函数调用成员的析构函数来撤销对象。

####管理指针的成员

使用标准库能够大大减少现代c++程序对指针的需要，但是在类的实现中仍然需要有很多指针的使用，包含指针的类要特别注意复制控制，原因在于复制指针时只复制指针中的地址，而不会复制指针指向的对象。  

当两个指针指向了同一个对象的时候，可能使用任意一个指针改变基础对象，类似的，很可能一个指针删除了一个对象，另一指针的用户还认为基础对象还在这样的错误情况，所以需要注意。  

c++采取了以下三种方法来管理指针：  

1. 指针成员采取常规指针型行为。这样的类具有指针的所有缺陷但无需特殊的复制控制。  
2. 类可以实现所谓的“智能指针”行为。指针所指向的对象是共享的，但类能够防止悬垂指针。  
3. 类采取值型行为。指针所指向的对象是唯一的，由每个类对象独立管理。  
4. const成员函数可以修改其所指向的字符。也就是说一个函数尽管是const类型，但是任然可以修改指针所指向的对象  

> 类对象的常量性决定了调用哪一个函数  

类直接复制指针的情况下，可能存在潜在的问题，可能出现悬垂指针：资源已经被回收或者指针不在指向有效的对象的时候可能出现悬垂指针，但是没有办法得知对象是否已经不存在了。  

####定义智能指针  

智能指针负责删除共享对象。 使用智能指针需要设计一个管理指针的类来实现计数功能，其方法之一是使用一个单独的具体类用以封闭使用计数和相关指针。  

采用了复制构造函数的时候，相当于创建了一个新的指针对象，因为每个对象保存了自己的副本，所以析构函数可以无条件的删除指针。  

赋值操作符不需要分配新的对象，只是必须给其指针所指向的对象赋新的值，而不是给指针本身赋值。改变的是指针所指向的值，而不是指针。  

分配内存或其他资源几乎总是需要定义复制控制成员来管理所分配的资源，如果一个类需要析构函数，则它几乎也总是需要复制构造函数和赋值操作符。

###重载操作符和转换

重载操作符必须具有一个类类型的操作数。操作数不能是常规的数据类型。内置操作符的定义不能改变，也就因此不能重新定义。  

也不能为内置数据类型重新定义加号操作符。例如不能接受两个数组操作数operator+.  

> 重载操作符必须至少需要一个类类型或者是枚举类型的操作数，这条规则强制重载操作符不能重新定义用于内置类型对象的操作符的含义。  

####优先级和结合性是固定的

重载操作符并不能保证操作数的求值顺序，尤其是不会保证内置逻辑AND、逻辑OR和逗号操作符的操作数求值。在 && 和 || 的重载版本中，两个操作数都要进行求值，一次重载　&& 和 || 不是一个好的选择。  

调用成员操作符函数跟普通函数一样，指定函数并传递适当类型的适当数目的形参。也可以这么理解：  

> 指定运行函数的对象，然后使用.或者->操作符获取希望调用的函数，同时传递所需数目和类型的实参。对于二次元操作符函数的情况，必须传递一个操作数。  

并且大多数的操作符对类来说并没有多大的意义。  

####输入输出操作符的重载

更重要但通常重视不够的是，输入和输出操作符有如下区别：输入操作符必须处理错误和文件结束的可能性。  

####调用操作符以及函数对象

可以为了类类型对象重载函数调用操作符。一般表示为操作的类的重载调用操作符。例如可以存在如下的代码结构：  

		struct class Test{
			int opertor (int val){
			}
		}
		//执行以上代码则可以正确迅速调用代码结构作为函数使用
		
> 函数作为标准库算法的实现，以及函数对象可以比函数更加的灵活和便于操作  
> 每个标准库的函数表示一个给定的操作符。每个类都定义了应用命名操作的调用操作符，不同的函数对象定义了执行不同操作的调用操作符，等等。  

####标准库函数基本摘抄所示

|算术函数类型对象|操作说明
| ----- | ------ |
|plus<Type> |加法操作
|minus<Type> |减法操作 
|multplies<Type> |乘法操作 
|divides<Type> |除法操作 

等等基本的操作都是可以先进行命名，然后直接调用操作符就可以了，如以下的代码所示：  

		plus<int> add_int;
		int sun=add_int(10,20);
		//得到的结果为两个数相加的和。其余的方法以此类推，可以直接先定义操作符，直接对两个数进行运
		算操作
> 函数对象经常会覆盖算法使用的默认操作符，如sort默认使用operator<按升序对容器进行排列>


###函数的继承以及实现  

对于虚函数，默认进行实现动态绑定，要触动态绑定满足两个条件、只有是虚函数的成员函数才能机型动态数据绑定，必须通过基类类型的引用或者是指针进行函数的调用。  

每个派生类对象都是包括基类的部分，所以可以将基类类型的引用绑定到派生类对象的基类部分，也可以使用指向基类的指针指向派生类的对象。  

###可以在运行的时候确定Virtual 函数的调用  

将基类类型的引用或者指针绑定到派生类的对象是对基类没有任何影响，对象的本身不会发生改变，仍然是派生类的对象，对象的实际类型可能不同于该对象的引用或指针的静态类型，这是c++中的数据动态绑定。  

有些基类的成员允许派生类进行访问，但是不允许其他的用户进行访问，这些成员应该使用受保护的类型标号来进行控制，protected 成员可以被派生类的对象进行访问但是不能被该类型的普通用户进行访问。  

protected 成员是private和public的混合。派生类只能通过访问基类的protected成员变量，派生类对于其基类类型的对象缺确是没有特殊的访问对象权限。  

###类的设计以及受保护的成员变量

如果没有继承的时候，类只有两种用户：1、类本身的成员 2、该类的用户。同Java一样的是，用户只能访问的是public接口，类成员以及友元既可以访问public成员也能访问pirvate基类的实现，所以在子类实现中为了提供访问控制，所以提供了protected变量控制。  

定义派生类的代码如下：  

		class A{
			public:
			private :
			protected:
		};
		class B :pulic A{
			public:
			private :
			protected:
		}

派生类和虚函数  

尽管不是必须要这么做，但是派生类中一般会重定义所继承的虚函数，派生类没有定义某一个虚函数的时候，则使用基类中的定义的版本。派生类型必须要对想要重定义的每个继承成员进行声明。派生类的虚函数的声明必须要于基类中的声明方式完全一致，派生类中的虚函数可以返回基类函数所返回的类型的派生类的指针或者引用都是可以的。函数一旦声明为虚函数的就一直为虚函数，派生类将无法改变这一事实。派生类重新定义虚函数时，可以使用virtual保留字， 	但是不是必须非要这么做。


###公有、私有和受保护的继承

派生类可以定义一个或者是多个的访问标号，指定在其随后的成员的访问级别。对类继承的成员访问由基类中的成员访问级别以及派生类中列表使用的访问标号来共同进行控制，每个类控制他所定义的成员访问，派生类可以进一步的限制但不能放松对继承成员的访问。例如在基类中如果是是private则在集成类中均不能访问该成员变量，如果在基类中是proteted或者是public时候，则派生类中使用的访问标号决定该成员在派生类中的访问级别。  

如果是共有继承public,基类成员保持自己的访问级别：基类的public成员为派生类中public 成员，基类的protected成员则是派生类中的Protected 成员。  

如果是受限制保护访问权限，基类的public和protected成员在派生类中为protected成员   

如果是私有继承。基类的所有成员在派生类中都是private成员  

无论派生列表中是什么访问标号，所有继承Base中的成员具有相同的访问，派生访问标号将控制派生类的用户对从Base继承而来的成员的访问。  

		class Base{
			public :
				void basemem();
			protected:
				int i;
		}

		struct Public_subclass : public Base{
			int use_base(){
				return i;	
			}
		}
		
		struct Prvate_subclass : private Base{
			int use_base(){
				return i;
			}
		}

		
		Base a;
		Public_subclass  sub1;
		Prvate_subclass  sub2;
		sub1.basemen();  
		sub2.basemen();  //error 错误的调用，因为Private_subclass是private继承基类
		所以Private_subclass对象不能访问基类中的成员变量，但是在子类中却能够访问变量。

		默认的继承访问权限都是private.即都是私有访问权限  



###接口继承与实现继承

public派生类继承基类的接口，它具有与基类相同的接口，public派生类的对象可以用在任何需要基类的地方。  

使用private或者是protected派生的类不继承基类的接口。相反的这些派生类通常被称之为实现继承，派生类在实现中使用继承但继承基类的部分并未成为接口的一部分。 最常见的继承方式仍然为public继承。  

###去除个别的成员变量

如果进行了private或者是protected继承，则基类中的成员访问级别在派生类中比在积累中比较受限：  

		class Base{
			public:
				std::size_t size() const {
					return n;
				}
			protected:
				std::size_t n;
		}

		class SubOne : private Base{
		
		}
		
派生类可以恢复继承成员的访问级别，但不能使访问级别比基类中的原来指定的更加严格或者更加宽松。意思也就是在继承中可以重新对成员的访问级别进行控制。例如以下的代码控制。  

		class SubTwo : private Base{
			public:
				using Base::size;
			protected:
				using Base::n;
		}

可以使用using 声明从命名空间使用名字，来改变成员变量的访问级别。 

###默认继承保护级别

可以使用默认的struct和class保留字定义的类具有不同的默认访问级别，同样，继承默认访问级别根据使用了哪一个保留字定义的派生类访问权限也不相同。class保留字保留了private访问级别，但是Struct 保留的默认访问级别确是public继承。 	

尽管class继承默认是private 继承，但是在使用的过程中private 继承是相当罕见的，通常显式指定了private是比依赖于默认更好的办法，显式制定可以清楚的指出想要私有继承而不是一时忽略。  


###友元关系与继承  

基类或者派生类可以使用其他类或者函数成为友元，友元可以访问类的private 或者是protected 数据，友元关系不能继承，如果基类被授予为友元关系，则只有基类具有特殊的访问权限，该基类的派生类不能访问授予友元关系的类。也就是说  

> 每个类单独控制自己的友元关系类

如果基类定义了一个static成员，则整个继承层次中只能一个这样的成员，无论从基类派生出多少个派生类。每个static成员只能有一个实例，static成员遵循了常规访问控制，如果成员在基类中为private ,则派生类不能访问它，假定可以访问成员，则既可以通过基类访问static成员，也可以通过派生类访问static成员，一般而言，可以使用作用域操作符也可以使用点或者箭头成员访问操作符。  

###继承与转换  

每个派生类对象包含了一个基类部分，这意味着可以像使用基类对象一样在派生类对象上执行操作，因为派生类对象也是基类对象，所以存在从派生类对象引用到基类类型的自动转换，可以将派生类对象的引用转换为基类子对象的引用，这一点对指针也是适用的。  

在用派生类对基类进行赋值的时候，要么定义适当的构造函数或者是通过赋值操作符来实现。  

基类一般(显示或者隐式的)定义自己的复制构造函数和赋值操作符，这些成员接受了一个形参，该形参是基类类型的引用，因为存在从派生类引用到基类引用的转换，这些复控制成员可用于从派生类对象对基类对象进行初始化或者赋值。  

###派生类到基类转换的可访问性  

像继承的成员函数一样，从派生类到基类的转换可能也不能不是可访问的，转换是否取决于在派生类列表中指定的访问标号。  

要确定到基类的转换是否可以访问，可以考虑其基类的public 成员是否访问，如果可以，转换是可以访问的，否则，转换则是不可以访问的。如果是public 访问，则用户的代码或者子类都是可以使用派生类到基类的转换，如果是private或者是protected 继承派生的，则用户代码不能将派生类类型对象转换到基类对象，派生类本身都是可以访问基类的public成员。

###基类到派生类的转换  

从基类到派生类的自动转换是不存在的，需要使用派生类对象的时候不能使用其基类对象，基类对象只能是基类对象，它不能包括派生类的成员，如果允许使用基类对象给派生类对象赋值，那么就可以试图使用该派生类对象访问不存在的成员。  

派生类的构造函数受到继承关系的影响。  


###复制控制和继承  

跟其他的任意类一样，派生类也可以使用合成复制控制成员，合成操作对象的基类部分连同派生部分的成员一起进行复制，赋值或者撤销，使用基类的复制构造函数、赋值操作符或者析构函数对基类部分进行了复制，赋值或者撤销。  

类是否需要定义复制控制成员完全取决于类自身的直接成员，基类可以定义自己的复制控制而派生类使用合成版本，反之亦然。  


###定义派生类复制构造函数  

如果派生类定义了自己的复制构造函数，该复制构造函数一般应显式使用基类构造函数初始化对象的基类部分。   

初始化函数将派生类对象转换为他的基类的部分引用，并且调用基类复制构造函数，如果省略了基类初始化构造函数，如下代码：  

 如果直接省略了初始化，默认初始化对象的基类部分。  

###派生类赋值操作符  

赋值操作符通常与复制构造函数类似：如果派生类定义了自己的赋值操作符，则该操作符必须对基类的部分进行显示的赋值，如以下的代码所示：  

```java 
	Subclass &Subclass::operator=(const Subclass &rhs){
		if(this!=&rhs){
			Base::operator=(rhs); //声明基类的部分
		}
		return *this;
	}
```
###派生类的析构函数  

机构函数与复制构造函数和赋值操作符不同：派生类析构函数不负责撤销基类对象的成员，编译器总是会显示调用派生类对象基类部分的析构函数，每个析构函数只负责清除自己的成员变量。  

```java
	class Subclass : public Base{
		public :
			~Subclass();
	}
```
对象的撤销顺序与构造函数的顺序是相反的，首先运行的是派生类析构函数，然后按照继承层次依次向上调用各基类的析构函数。  

###虚析构函数  

自动调用基类部分的析构函数对基类的设计具有重要的影响。删除指向动态分配对象的指针。需要运行析构函数在释放对象的内存之前清除对象，处理继承层次中的对象时，指针的静态类型可能与被删除对象的动态类型不同，可能会删除实际指向派生类对象的基类类型指针。  

所以需要删除基类指针的时候，需要运行基类的析构函数并且清除基类的成员，如果对象实际上是派生类型的，则没有定义该行为，要保证运行适当的析构函数，基类中的机构函数必须为虚函数。  

```java 
	class Base{
	public:		
		virtual ~ Base();
	}
	
```

如果析构函数时虚函数，那么通过指针调用的时候，运行哪个虚函数将因指针对象类型的不同而不同。析构函数的虚函数特性将会保持下去，派生类的析构函数也是虚函数，无论派生类显示定义析构函数还是使用了合成析构函数，派生类析构函数都是虚函数。  

如果类需要析构函数，则类几乎也确实需要其他复制控制成员。基类总是需要构造函数，从而可以将析构函数设置为虚函数，即使析构函数里面没有工作要做，继承层次的根类也应该定义一个虚析构函数。  

###构造函数和析构函数中的虚函数  

构造派生类对象首先运行基类构造函数初始化对象的基类部分，在执行基类构造函数时，对象的派生类部分是未初始化的，实际上此时对象还不是一个派生类对象。撤销一个派生类对象的时候，首先撤销的是它的派生类部分，然后按照顺序逆序撤销它的基类部分。  

在这种情况下，运行构造函数或者析构函数的时候，对象都是不完整的，为了适用这种不完整，编译器将对象的类型视为在构造或解析期间发生了变化，在基类构造函数或者析构函数中，将派生类对象当做基类类型对待。  

构造或析构期间对象类型对虚函数的绑定有影响。如果在构造函数或者析构函数中调用了虚函数，则运行的是为构造函数或析构函数自身类型定义的版本，所以无论由构造函数直接调用虚函数或者从构造函数所调用的函数间接调用虚函数，都应用这种绑定。


###继承情况下的类作用域  

每个类保持着自己的作用域，在该作用域中定义了成员的名字。在继承情况下派生类的作用域嵌套在基类的作用域中，如果在派生类中不能确定名字，则就在外围基类的作用域中使用名字命名的方式来进行名字查找的定义。正是这些类作用域的层次嵌套使我们能够直接访问基类的成员，就像这些成员是派生类的成员一样。  

