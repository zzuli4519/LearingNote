###复制函数，析构函数，赋值操作符----复制控制

对于类类型对象，只有指定单个实参或显式创建一个临时对象用于复制时，才可以复制初始化。复制构造函数就是接受单个类类型引用形参（通常需要使用const来进行修饰）的构造函数：  

		class Test{
			Test(std::string);
			Test(const Test&);
		} 
		//虽然也可以接受一个非const引用的复制构造函数，但是形参通常应该是一个const引用。 
		//不应该将隐式转换与复制构造函数混淆
定义构造函数一般比较简单，使用构造函数初始化列表可以创建新的类对象成员，可以在函数体中做其他任何必要的工作。  

####禁止复制

有些类要完全禁止复制，但是如果不定义复制函数的话，编译器将自动合成一个复制函数，为了便面复制函数，需要将复制函数显示的声明为private。如果复制函数是私有的，将不允许用户代码复制该类类型的对象，然而友元和成员是可以进行复制的，如果避免友元和成员的复制也禁止的话，就可以声明一个private复制构造函数，但是不比对其进行任何的定义。  

> 大多数的类应该定义复制构造函数和默认构造函数，不允许复制的类不能作为容器的元素。（注意点）


> 只有当类的定义体完成之后才能定义，因此类不能拥有自身类型的数据成员，然而只要类名一出现的话就是可以认为该类已经声明，也即因此类的数据成员可以是指向自身类型的引用或者指针。  

	class Test{
		Test* mem1;
		Test& mem2;
		//以上两种是合法的
		Test mTest; // 这种声明方式是错误的
	}

####重载操作符

重载操作符是一些函数，其名字为operator后面跟上操作符的符号。因此可以定义名为operator=函数。我们可以对赋值进行定义，像任何其他函数一样，操作符有一个返回值和一个形参表。形参表表示必须具有与该操作符数目相同的形参(如果操作符是一个类成员，则应该包括隐式this)大多数的操作符都是可以定义为成员函数或非成员函数。当操作符为成员函数的时候。它的第一个操作数隐式绑定到this指针。

####何时调用析构函数

撤销对象，清除对象所占用的引用的时候将会自动调用析构函数。  

如代码所示：  
		
		Test *p=new Test;
		{
			delete p; //删除占用对象引用			
		}

一个变量在超出作用域的时候应该自动撤销，因此当遇到右花括号的时候，将运行析构函数来执行清理程序。但是对于动态分配的指针之类的对象，只有在指针被删除时才会被撤销，如果没有删除指向动态对象的指针，将不会运行该对象的析构函数，对象就会一直存在，从而导致内存泄露的发生，而且对象内部使用的任何资源也不会得到释放。  

撤销一个容器，也将会运行容器中的类型元素的析构函数：  
		{
			Test *p=new Test[10];
			vector<Test> vec(p, p + 10);
			delete [] p;
		}

容器中的元素总是按照逆序的顺序执行销毁，直到撤销到下标为0的元素。析构函数通常用于释放在构造函数或在对象生命期内获取的资源进行清理工作。

>  需要注意的一点：如果一个类需要析构函数，则也需要复制函数以及赋值操作符，这被称之为`三法则`指的是如果需要析构函数则需要所有这三个复制控制成员。  
>  析构函数可以执行任意操作，一般是在对象使用完毕之后执行的。

####合成析构函数

编译器总是会为我们创建一个析构函数。合成析构函数按对象创建时逆序撤销每个非static成员。因此，他按照成员在类中声明次序的逆序撤销成员，对于每个类类型的每个成员，合成析构函数调用成员的析构函数来撤销对象。

####管理指针的成员

使用标准库能够大大减少现代c++程序对指针的需要，但是在类的实现中仍然需要有很多指针的使用，包含指针的类要特别注意复制控制，原因在于复制指针时只复制指针中的地址，而不会复制指针指向的对象。  

当两个指针指向了同一个对象的时候，可能使用任意一个指针改变基础对象，类似的，很可能一个指针删除了一个对象，另一指针的用户还认为基础对象还在这样的错误情况，所以需要注意。  

c++采取了以下三种方法来管理指针：  

1. 指针成员采取常规指针型行为。这样的类具有指针的所有缺陷但无需特殊的复制控制。  
2. 类可以实现所谓的“智能指针”行为。指针所指向的对象是共享的，但类能够防止悬垂指针。  
3. 类采取值型行为。指针所指向的对象是唯一的，由每个类对象独立管理。  
4. const成员函数可以修改其所指向的字符。也就是说一个函数尽管是const类型，但是任然可以修改指针所指向的对象  

> 类对象的常量性决定了调用哪一个函数  

类直接复制指针的情况下，可能存在潜在的问题，可能出现悬垂指针：资源已经被回收或者指针不在指向有效的对象的时候可能出现悬垂指针，但是没有办法得知对象是否已经不存在了。  

####定义智能指针  

智能指针负责删除共享对象。 使用智能指针需要设计一个管理指针的类来实现计数功能，其方法之一是使用一个单独的具体类用以封闭使用计数和相关指针。  

采用了复制构造函数的时候，相当于创建了一个新的指针对象，因为每个对象保存了自己的副本，所以析构函数可以无条件的删除指针。  

赋值操作符不需要分配新的对象，只是必须给其指针所指向的对象赋新的值，而不是给指针本身赋值。改变的是指针所指向的值，而不是指针。  

分配内存或其他资源几乎总是需要定义复制控制成员来管理所分配的资源，如果一个类需要析构函数，则它几乎也总是需要复制构造函数和赋值操作符。

###重载操作符和转换

重载操作符必须具有一个类类型的操作数。操作数不能是常规的数据类型。内置操作符的定义不能改变，也就因此不能重新定义。  

也不能为内置数据类型重新定义加号操作符。例如不能接受两个数组操作数operator+.  

> 重载操作符必须至少需要一个类类型或者是枚举类型的操作数，这条规则强制重载操作符不能重新定义用于内置类型对象的操作符的含义。  

####优先级和结合性是固定的

重载操作符并不能保证操作数的求值顺序，尤其是不会保证内置逻辑AND、逻辑OR和逗号操作符的操作数求值。在 && 和 || 的重载版本中，两个操作数都要进行求值，一次重载　&& 和 || 不是一个好的选择。  

调用成员操作符函数跟普通函数一样，指定函数并传递适当类型的适当数目的形参。也可以这么理解：  

> 指定运行函数的对象，然后使用.或者->操作符获取希望调用的函数，同时传递所需数目和类型的实参。对于二次元操作符函数的情况，必须传递一个操作数。  

并且大多数的操作符对类来说并没有多大的意义。  

####输入输出操作符的重载

更重要但通常重视不够的是，输入和输出操作符有如下区别：输入操作符必须处理错误和文件结束的可能性。  

####调用操作符以及函数对象

可以为了类类型对象重载函数调用操作符。一般表示为操作的类的重载调用操作符。例如可以存在如下的代码结构：  

		struct class Test{
			int opertor (int val){
			}
		}
		//执行以上代码则可以正确迅速调用代码结构作为函数使用
		
> 函数作为标准库算法的实现，以及函数对象可以比函数更加的灵活和便于操作  
> 每个标准库的函数表示一个给定的操作符。每个类都定义了应用命名操作的调用操作符，不同的函数对象定义了执行不同操作的调用操作符，等等。  

####标准库函数基本摘抄所示

|算术函数类型对象|操作说明
| ----- | ------ |
|plus<Type> |加法操作
|minus<Type> |减法操作 
|multplies<Type> |乘法操作 
|divides<Type> |除法操作 

等等基本的操作都是可以先进行命名，然后直接调用操作符就可以了，如以下的代码所示：  

		plus<int> add_int;
		int sun=add_int(10,20);
		//得到的结果为两个数相加的和。其余的方法以此类推，可以直接先定义操作符，直接对两个数进行运
		算操作
> 函数对象经常会覆盖算法使用的默认操作符，如sort默认使用operator<按升序对容器进行排列>


###函数的继承以及实现  

对于虚函数，默认进行实现动态绑定，要触动态绑定满足两个条件、只有是虚函数的成员函数才能机型动态数据绑定，必须通过基类类型的引用或者是指针进行函数的调用。  

每个派生类对象都是包括基类的部分，所以可以将基类类型的引用绑定到派生类对象的基类部分，也可以使用指向基类的指针指向派生类的对象。  

###可以在运行的时候确定Virtual 函数的调用  

将基类类型的引用或者指针绑定到派生类的对象是对基类没有任何影响，对象的本身不会发生改变，仍然是派生类的对象，对象的实际类型可能不同于该对象的引用或指针的静态类型，这是c++中的数据动态绑定。  

有些基类的成员允许派生类进行访问，但是不允许其他的用户进行访问，这些成员应该使用受保护的类型标号来进行控制，protected 成员可以被派生类的对象进行访问但是不能被该类型的普通用户进行访问。  

protected 成员是private和public的混合。派生类只能通过访问基类的protected成员变量，派生类对于其基类类型的对象缺确是没有特殊的访问对象权限。  

###类的设计以及受保护的成员变量

如果没有继承的时候，类只有两种用户：1、类本身的成员 2、该类的用户。同Java一样的是，用户只能访问的是public接口，类成员以及友元既可以访问public成员也能访问pirvate基类的实现，所以在子类实现中为了提供访问控制，所以提供了protected变量控制。  

定义派生类的代码如下：  

		class A{
			public:
			private :
			protected:
		};
		class B :pulic A{
			public:
			private :
			protected:
		}

派生类和虚函数  

尽管不是必须要这么做，但是派生类中一般会重定义所继承的虚函数，派生类没有定义某一个虚函数的时候，则使用基类中的定义的版本。派生类型必须要对想要重定义的每个继承成员进行声明。派生类的虚函数的声明必须要于基类中的声明方式完全一致，派生类中的虚函数可以返回基类函数所返回的类型的派生类的指针或者引用都是可以的。函数一旦声明为虚函数的就一直为虚函数，派生类将无法改变这一事实。派生类重新定义虚函数时，可以使用virtual保留字， 	但是不是必须非要这么做。


###公有、私有和受保护的继承

派生类可以定义一个或者是多个的访问标号，指定在其随后的成员的访问级别。对类继承的成员访问由基类中的成员访问级别以及派生类中列表使用的访问标号来共同进行控制，每个类控制他所定义的成员访问，派生类可以进一步的限制但不能放松对继承成员的访问。例如在基类中如果是是private则在集成类中均不能访问该成员变量，如果在基类中是proteted或者是public时候，则派生类中使用的访问标号决定该成员在派生类中的访问级别。  

如果是共有继承public,基类成员保持自己的访问级别：基类的public成员为派生类中public 成员，基类的protected成员则是派生类中的Protected 成员。  

如果是受限制保护访问权限，基类的public和protected成员在派生类中为protected成员   

如果是私有继承。基类的所有成员在派生类中都是private成员  

无论派生列表中是什么访问标号，所有继承Base中的成员具有相同的访问，派生访问标号将控制派生类的用户对从Base继承而来的成员的访问。  

		class Base{
			public :
				void basemem();
			protected:
				int i;
		}

		struct Public_subclass : public Base{
			int use_base(){
				return i;	
			}
		}
		
		struct Prvate_subclass : private Base{
			int use_base(){
				return i;
			}
		}

		
		Base a;
		Public_subclass  sub1;
		Prvate_subclass  sub2;
		sub1.basemen();  
		sub2.basemen();  //error 错误的调用，因为Private_subclass是private继承基类
		所以Private_subclass对象不能访问基类中的成员变量，但是在子类中却能够访问变量。

		默认的继承访问权限都是private.即都是私有访问权限






