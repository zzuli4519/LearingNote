###第一章  
2.1.1简单数据类型练习题：  
1、如果某机器上short类型占了16位，那么赋值给short类型的最大数是多少？unsigned short类型的最大数是多少？  

	倘若占了16位，则第一位是符号位，也即是最大值为2的15次方减1  

###第三章 C++ 输入输出  
1、输出 `cout << "HelloWorld" << endl;`  
2、输入 `cin >> x ;`

### c++ 使用枚举类型 
在c++枚举类型中，默认地，第一个枚举成员赋值为 0，后面的每个枚举成员赋的值比前面的大 1。允许在C++类型中值不是唯一的，也即是可以存在相同的值。  

		enum nameType{
			nameZhang=1,
			nameYang,
			nameFang=2
		}
		或者不申明参数类型 ---> enum open_modes {input, output, append};
###c++中类类型
c++ 中通过定义类来自定义数据类型 ，定义了该类型的对象包含的数据和该类型的对象可以执行的操作，标准库istream ostream string 都是定义成类的对象。 
 
每个类都定义了一个接口以及一个实现。接口由使用该类的代码需要执行的操作组成，实现一般包括该类所需要的数据，实现还包括定义该类需要的但又不提供一般性使用的函数。  

定义类的时候一般先定义该类的接口，即该类所提供的的操作，通过这些操作可以决定该类完成其功能所需要的数据，以及是否需要定义一些函数来支持该类的实现。  

>首先将要定义的类型所支持的操作，例如加法操作符，输入以及输出操作符，赋值操作符，检查是否一致操作符等。   

如果使用class来定义一个类，那么定义在第一个标号之前的所有成员都隐式的指定为private。如果使用struct关键字来定义类，仅仅影响默认的初始化访问级别，也就是说在第一个标号之前的成员变量都是public级别。 默认的是struct的访问级别都是public，而class的默认访问级别都是private。除非进行了申明。  
>需要注意的一点是在于申明class类结束的时候要带上`;`作为结束。  

###编写并设计自己的头文件 
一般类的定义都会放到`头文件`中。C++中使用头文件包含的不仅仅是类的定义，名字在使用前必须要声明或者定义。  
头文件为相关声明提供了一个集中存放的位置，头文件一般包含了文件的定义、extern 变量的声明以及函数的声明，使用或者定义这些实体的文件要包含适当的头文件。  
头文件的正确使用好处为:  
	1、保证所有文件都是使用给定实体的唯一声明  
	2、当声明文件需要修改的时候，只有头文件需要更新  

头文件包含在多个源文件中，因此不应该含有变量或者函数的定义。设计头文件时，定义和声明的区别是很重要的，定义只能出现一次，而申明可以出现多次。对于一些常量const可以直接初始化变量。如果不是const变量则应该在一个源文件中并初始化定义。应该在文件中用extern进行申明，以便于能被多个文件引用。  

###预处理器的简单介绍
要使用头文件必须要在源文件中#include该头文件，#include是c++预处理器的一部分。预处理器处理程序源代码，在编译器运行之前运行，C++继承了C的非常精细的预处理器，现在的C++程序以高度受限的方式使用预处理器。  

`#include`指示只能接受一个参数：头文件名。预处理器用指定的头文件的内容替代每个`#include`,系统的头文件可能用特定于编译器的更高效的格式保存。  

为了可以保证多次包含同一个头文件不会引起该头文件的类和对象被多次声明，使用预处理器定义头文件保护符，头文件保护符用于避免在已经见到头文件的情况下重新处理该头文件的内容。  
###避免多重包含
在编写头文件之前，需要引入一些额外的预处理器设施，预处理器允许我们自定义变量。  

预处理器变量的名字在程序中必须是唯一的。任何与预处理器变量相匹配的名字的使用都关联到该预处理器变量。为了避免冲突，预处理器的名字经常用全大写字母表示：  

		预处理器的状态：已经定义/未定义，定义预处理器变量和检测其状态所用到的预处理器指示不
		同。#define 指示接受一个名字，并且定义该名字为预处理器变量。#ifndef 指示检测指定的
		预处理器变量是否未定义，如果未被定义，则跟在其后的所有指示都将被执行，
		直到出现#endif,可以使用这些设施来预防多次包含同一个头文件。  
		
		//定义预处理器的名字一般都是大写
		#ifndef SALESITEM_H
		#define SALESITEM_H
		//定义类成员以及方法都在此声明
		#endif
###使用自定义的头文件
使用头文件一般使用一下的两种方式：  

		#include <standard_header>
		#include "my_file.h"
		如果是在<>中，则认为该文件是标准的头文件，编译器会在预定义的位置查找该头文件，这
		些预定义的位置可以通过设置查找路径环境变量或者通过命令行选项来修改。使用的查找方
		法因为编译器的不停而差别迥异。如果是在“”中则认为是用户自定义的头文件。非系统的头文件的查找通常开始于源文件所在的路径。
  
C++中变量可以声明多次但是只能定义一次。（但是对于基本数据类型，声明的时候也即是定义的时候）。c++是一种静态类型语言，定义变量的时候就进行初始化总是稳妥的主意。  

###学习下一章术语

>access labels (访问标号)：类的成员可以被定为private以及public。使用方式以及原理类似于java  

>address(地址) 一个数字，通过该数字可以在存储器上找到一个字节。  

>arithmetic types（算术类型）表示数值一般有整数和浮点数的类型。浮点类型有三种类型：double,float,long double。一般使用的总是double类型，因为float只能保证6位的有效数字，这对于大多数的计算来说都是不够的。  
>
>array (数组)  
>
>byte (字节) 最小的可寻址存储单元。大多数的机器上一个字节有8位（bit）  
>
>class （类）  
>
>classMember (类的成员)  
>
>compound type (复合类型)  
>
>const reference（const 引用)  
>
>constant expression（常量表达式)  
>
>constructor（构造函数）  
>
>....等等数据类型，详情请参考pdf第三章前

###标准库类型

C++还定义了一个内容丰富的抽象数据类型标准库，其中最基本的标准库类型是string 和 vector ,他们分别定义了大小可变的字符串以及集合。string 和 vector 往往将迭代器用作配套类型(companion Type)。  
另一种标准数据库类型是bitset,提供了一种抽象的方法来操作位的集合。与整型值上的位操作符来比较,bitset提供了一种更方便的位处理的方式。  

string函数中将istream 参数作为返回值，和输入操作符一样也可以用作判断条件。getline函数不能包含换行符，因此需要换行的时候只能手动输入。换行符不会存储在string对象中。  

一些string 对象的操作:  

		s.empty(); 如果字符串为空，则返回true，否则返回false
		s.size();  返回s中字符的个数
		s[n];      返回s中位置为N的字符  
		s1+s2;     拼接字符串，返回生成新的字符串
		s1==s2     判断字符串是否相等，相等返回true，否则返回false
string类型通过下标[]来进行访问string对象中的某一个字符。但是下标取值需要一个string_type 类型的值，来标明要访问字符的位置。这个下标的值通常被称作为“下标”或者“索引”  
		
		例如如下代码:
		string s="deadawdawd";
		for(string::size_type i=0;i!=s.size();++i){
			cout << s[i] << endl;
		}

需要对string对象进行操作，则需要调用头文件cctype类型 `include "cctype"` 有关cctype中的函数一般存在如下：  
对于上述函数一般测试给定字符是否满足条件。如果测试失败则函数返回0，测试为真当返回一个无意义的非0，表示被测字符符合条件。  

###标准库vector类型  
vector是同一种类型的对象的集合，每一个对象都有一个对应的整数索引值，和string对象一样。标准库将负责管理与存储元素相关的内存，我们把vector称之为容器，是因为它可以包含其他的对象。一个容器中的所有对象必须是类型相同的。使用vector之前，必须包含相同的头文件`include <vector>`以及`using std::vector`。  

vector是一个类型模板，使用模板可以编写一个类的定义或者函数的定义，而用于多个不同的数据类型，使用类模板的时候只需要了解类模板是如何定义的就可以了。  

声明从类模板产生的某种类型的对象，需要提供附加的信息，信息的种类取决于模板。以vector为例，必须说明vector使用的是何种类型的对象，通过该类型放在<>尖括号之后来进行定义声明。  

###vector关健概念:vector对象动态增长
vector对象的重要属性在于可以在运行时高效的添加元素。因为vector增长的效率高，在元素值已知的情况下，最好是动态的增加元素。
 
vector提供了一些操作，例如判断集合是不是为空，集合中元素的个数。在集合的末尾增加元素，如以下的例子：  

		vector s;
		s.empty();
		s.size();
		s.push_back(t);

vector对象中的size操作类似于string对象中的相关操作。成员函数size返回相应的vector类定义的size_type的值。  

使用size_type类型时，必须指出该类型是在哪里定义的。vector类型总是包括vector的元素的类型：  

		vector<int>::size_type i; //正确写法  
		vector::size_type i;      //错误写法

向vector添加元素  

push_back()操作接受一个元素值，并且把他作为一个新的元素添加到vector对象的后面，也就是"插入(push)"到vector对象的后面"back"  

如一下代码：  

	string word;
	vector<string> text;
	while(cin >> world){
		text.push_back(world); //append word to text
	}

###安全的泛型编程

c++与java一些编程的区别，例如在for循环中一般使用`!=`作为判断的依据，而不使用`<=`。C++程序习惯上优先选用`!=`来作为判断的依据  

###迭代器的使用
除了使用下标来访问集合里面的元素，标准库还提供了迭代器来访问集合中的元素：使用迭代器(iterator),迭代器是一种检查容器内元素并遍历元素的数据类型。  

标准库为每一种标准容器（包括vector）定义了一种迭代器类型。迭代器类型提供了比下标操作更通用的方法：所有的标准库容器都定义了相应的迭代器类型，而只有少数的容器支持下标操作。因为迭代器对所有的容器都适用。

###容器的iterator类型

每种容器类型都定义了自己的迭代器类型，如:  
	
	vector<int>::iterator iter;  

迭代器begin和end操作:每种容器都定义了一对命名为begin和end函数，用户返回迭代器，如果容器中有元素的话，由begin返回的迭代器指向第一个元素。  

	vector<int>::iterator iter=ivec.begin();  
迭代器的自增和解引用运算  

迭代器类型定义了一些操作来获取迭代器所指向的元素，并允许程序员将迭代器从一个元素移动到另一个元素，迭代器类型可以使用解引用操作（dereference operator）(*)来访问迭代器所指向的元素：  

	*iter=0; （* 解引用操作符 可以直接对元素进行访问）
	可以直接对迭代器的指针进行自增操作（++iter）
	对于调用了end操作的迭代器则不能使用解引用或者是自增操作，因为该指针此时不指向任何元素
		
对于从const_iterator则只能读取容器里面的值，不能改变容器里面的值。对此种对象进行解引用的时候得到的是一个指向const对象的引用。因为是常量对象，所以不能进行修改，只能进行引用操作  

###迭代器的算术操作

除了一次移动迭代器的一个元素的增量操作符外，vector迭代器也能支持其他元素的的算数操作，这些操作称之为迭代器算术操作  

###标准库bitset
位是用来保存一组项或者条件的yes/no 信息（有时也称之为标记）的简洁方法。标准库提供的bitset类简化了位集的处理，要使用bitset就必须要包含相关的头文件 std::bitset 的using声明如下：  

	#include <bitset>
	using std::bitset;
string对象可以和bitset对象进行相互转换，但是需要注意的地方在于bitset和string进行转化的时候，读取string对象是从右到左，意思也就是说bitset跟string 读取的顺序是相反的，bitset的高阶位是string的初始位置。(意思即为低阶位代表string字符的最大位置）  

string.size()以及vector.size()返回的数据类型是string::size_type以及vector::size_type
	
###数组以及指针
定义数组的时候需要注意的地方在于不能使用用一个数组对另一个数组直接进行初始化，也不能将一个数组赋值给另一个数组，这些都是非法的。如果希望编写的程序能在不同的编译器上运行，则应该避免使用像数组赋值这类依赖于编译器的非标准功能。  

>需要注意的地方在于：数组的长度都是固定的，不能对数组中执行类似于添加元素的操作，
如果必须要添加元素的话，程序员就必须自己管理内存，要求系统分配一个新的内存空间来
存放更大的数组，然后将原数组值复制到新分配的内存空间中  

###指针的引入
vector的遍历可以使用下标或者迭代器来实现，同理也可以使用下标或者指针来遍历数组。指针是指向某种类型对象的复合数据类型。是用作数组的迭代器：指向数组中的一个元素。在指向数组元素的指针上使用解引用操作符 * 和 自增操作符 ++ ，与在迭代器上的用法类似。对指针进行解引用操作，可以获得该指针所指向的对象的值。  

指针的详细使用说明：  

指针的概念：指针是用于指向对象。于迭代器一样。指针所提供对其所指对象的间接访问，只是指针结构更简单通用一点，迭代器可以指向集合中所有的对象。但是指针只能指向单一对象。具体来说指针保存的是另一个对象的地址。       

